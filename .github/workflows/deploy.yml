name: Deploy Services

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  detect-changes:
    runs-on: self-hosted
    outputs:
      changed-services: ${{ steps.changed-services.outputs.changed_services }}
      deleted-services: ${{ steps.changed-services.outputs.deleted_services }}
      all-services: ${{ steps.changed-services.outputs.all_services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v46
        with:
          files: services/**
          dir_names: true
          dir_names_max_depth: 2

      - name: Detect changed services
        id: changed-services
        run: |
          # Get all changed directories in services/
          changed_dirs="${{ steps.changed-files.outputs.all_changed_files }}"
          deleted_dirs="${{ steps.changed-files.outputs.deleted_files }}"

          # Initialize arrays
          changed_services=()
          deleted_services=()
          all_services=()

          # Get all existing services
          if [ -d "services" ]; then
            for service_dir in services/*/; do
              if [ -d "$service_dir" ]; then
                service_name=$(basename "$service_dir")
                all_services+=("$service_name")
              fi
            done
          fi

          # Process changed directories (existing services that changed)
          for dir in $changed_dirs; do
            if [[ "$dir" == services/* ]]; then
              # Extract service name (first subdirectory under services/)
              service_path=${dir#services/}
              service_name=${service_path%%/*}
              
              if [ -n "$service_name" ] && [ "$service_name" != "services" ]; then
                if [ -d "services/$service_name" ]; then
                  # Service still exists, it's changed
                  if [[ ! " ${changed_services[@]} " =~ " ${service_name} " ]]; then
                    changed_services+=("$service_name")
                  fi
                fi
              fi
            fi
          done

          # Process deleted directories (services that were removed)
          for dir in $deleted_dirs; do
            if [[ "$dir" == services/* ]]; then
              # Extract service name (first subdirectory under services/)
              service_path=${dir#services/}
              service_name=${service_path%%/*}
              
              if [ -n "$service_name" ] && [ "$service_name" != "services" ]; then
                # Add to deleted services if not already present
                if [[ ! " ${deleted_services[@]} " =~ " ${service_name} " ]]; then
                  deleted_services+=("$service_name")
                fi
              fi
            fi
          done

          # Convert arrays to JSON (compact format for GitHub Actions)
          if [ ${#changed_services[@]} -eq 0 ]; then
            changed_services_json="[]"
          else
            changed_services_json=$(printf '%s\n' "${changed_services[@]}" | jq -R . | jq -s -c .)
          fi

          if [ ${#deleted_services[@]} -eq 0 ]; then
            deleted_services_json="[]"
          else
            deleted_services_json=$(printf '%s\n' "${deleted_services[@]}" | jq -R . | jq -s -c .)
          fi

          if [ ${#all_services[@]} -eq 0 ]; then
            all_services_json="[]"
          else
            all_services_json=$(printf '%s\n' "${all_services[@]}" | jq -R . | jq -s -c .)
          fi

          echo "changed_services=$changed_services_json" >> $GITHUB_OUTPUT
          echo "deleted_services=$deleted_services_json" >> $GITHUB_OUTPUT
          echo "all_services=$all_services_json" >> $GITHUB_OUTPUT

          echo "Changed services: $changed_services_json"
          echo "Deleted services: $deleted_services_json"
          echo "All services: $all_services_json"

  stop-deleted-services:
    runs-on: self-hosted
    needs: detect-changes
    if: needs.detect-changes.outputs.deleted-services != '[]'
    steps:
      - name: Stop and remove deleted services
        run: |
          deleted_services='${{ needs.detect-changes.outputs.deleted-services }}'

          # Parse JSON array and process each service
          echo "$deleted_services" | jq -r '.[]' | while read -r service; do
            if [ -n "$service" ]; then
              echo "Stopping and removing service: $service"

              # Stop and remove containers
              docker compose -p "$service" down --remove-orphans || true

              # Remove unused volumes (optional, be careful with this)
              # docker volume prune -f

              echo "Service $service has been stopped and removed"
            fi
          done

  deploy-changed-services:
    runs-on: self-hosted
    needs: [detect-changes, stop-deleted-services]
    if: always() && needs.detect-changes.outputs.changed-services != '[]'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy changed services
        env:
          SECRETS_JSON: ${{ toJSON(secrets) }}
          VARS_JSON: ${{ toJSON(vars) }}
        run: |
          changed_services='${{ needs.detect-changes.outputs.changed-services }}'

          # Export all secrets and variables as environment variables
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "export \(.key)=\(.value)"' > /tmp/secrets.env
          echo "$VARS_JSON" | jq -r 'to_entries[] | "export \(.key)=\(.value)"' > /tmp/vars.env

          # Parse JSON array and process each service sequentially
          echo "$changed_services" | jq -r '.[]' | while read -r service; do
            if [ -n "$service" ]; then
              echo "=== Processing service: $service ==="
              
              service_dir="services/$service"

              # Validate service configuration
              echo "Validating service configuration for: $service"
              if [ ! -d "$service_dir" ]; then
                echo "Error: Service directory $service_dir does not exist"
                exit 1
              fi

              if [ ! -f "$service_dir/docker-compose.yml" ] && [ ! -f "$service_dir/docker-compose.yaml" ]; then
                echo "Error: No docker-compose file found in $service_dir"
                exit 1
              fi

              echo "Service $service configuration is valid"

              # Deploy the service
              echo "Deploying service: $service"
              cd "$service_dir"

              # Source all secrets and variables as environment variables
              set -a  # automatically export all variables
              source /tmp/secrets.env 2>/dev/null || true
              source /tmp/vars.env 2>/dev/null || true
              set +a  # disable automatic export

              # Stop existing containers
              docker compose -p "$service" down || true

              # Pull latest images
              docker compose -p "$service" pull

              # Start the service
              docker compose -p "$service" up -d

              # Wait a moment for the service to start
              sleep 5

              # Check if containers are running
              if docker compose -p "$service" ps --services --filter "status=running" | grep -q .; then
                echo "✅ Service $service deployed successfully"
              else
                echo "⚠️ Warning: Some containers in service $service may not be running"
                docker compose -p "$service" ps
              fi

              echo "Completed deployment of service: $service"
              echo ""
              cd - > /dev/null
            fi
          done

          # Clean up temporary files
          rm -f /tmp/secrets.env /tmp/vars.env

  health-check-and-recovery:
    runs-on: self-hosted
    needs: [detect-changes, deploy-changed-services, stop-deleted-services]
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Health check and recovery
        env:
          SECRETS_JSON: ${{ toJSON(secrets) }}
          VARS_JSON: ${{ toJSON(vars) }}
        run: |
          echo "=== Health Check and Recovery ==="

          # Export all secrets and variables as environment variables
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "export \(.key)=\(.value)"' > /tmp/secrets.env
          echo "$VARS_JSON" | jq -r 'to_entries[] | "export \(.key)=\(.value)"' > /tmp/vars.env

          # Source all secrets and variables
          set -a  # automatically export all variables
          source /tmp/secrets.env 2>/dev/null || true
          source /tmp/vars.env 2>/dev/null || true
          set +a  # disable automatic export

          # Check all services in the services directory
          for service_dir in services/*/; do
            if [ -d "$service_dir" ]; then
              service=$(basename "$service_dir")
              echo "Checking health of service: $service"
              
              cd "$service_dir"
              
              # Check if any containers are supposed to be running
              if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
                # Get list of services that should be running
                running_services=$(docker compose -p "$service" ps --services --filter "status=running" 2>/dev/null || echo "")
                expected_services=$(docker compose -p "$service" config --services 2>/dev/null || echo "")
                
                if [ -n "$expected_services" ]; then
                  if [ -z "$running_services" ]; then
                    echo "⚠️ Service $service has no running containers. Attempting recovery..."
                    docker compose -p "$service" up -d
                    sleep 10
                    
                    # Check again
                    running_services=$(docker compose -p "$service" ps --services --filter "status=running" 2>/dev/null || echo "")
                    if [ -n "$running_services" ]; then
                      echo "✅ Service $service recovered successfully"
                    else
                      echo "❌ Service $service failed to recover"
                      docker compose -p "$service" logs --tail=20
                    fi
                  else
                    echo "✅ Service $service is running"
                  fi
                fi
              fi
              
              cd - > /dev/null
            fi
          done

          # Clean up temporary files
          rm -f /tmp/secrets.env /tmp/vars.env

          echo "=== Health check completed ==="
