name: Deploy Docker Services

on:
  push:
    branches: [main, master] # Adjust branches as needed
  workflow_dispatch: # Allows manual triggering

env:
  SERVICES_DIR: "services"
  STATE_FILE: "/tmp/deployed_services.txt"

jobs:
  deploy-services:
    runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # Needed to detect changes

      - name: Set up environment
        run: |
          echo "ðŸš€ Starting Docker services deployment"
          echo "GITHUB_SHA=${GITHUB_SHA}" >> $GITHUB_ENV
          echo "GITHUB_RUN_ID=${GITHUB_RUN_ID}" >> $GITHUB_ENV

          # Create logs directory
          mkdir -p logs

          # Set proper permissions for Docker socket if needed
          sudo chmod 666 /var/run/docker.sock 2>/dev/null || true

      - name: Discover current services
        id: discover
        run: |
          echo "ðŸ” Discovering services in ${SERVICES_DIR} directory..."

          # Find all directories with docker-compose.yml, docker-compose.yaml, or compose.yaml files
          current_services=""
          if [ -d "${SERVICES_DIR}" ]; then
            for service_dir in ${SERVICES_DIR}/*/; do
              if [ -f "${service_dir}docker-compose.yml" ] || [ -f "${service_dir}docker-compose.yaml" ] || [ -f "${service_dir}compose.yaml" ] || [ -f "${service_dir}compose.yml" ]; then
                service_name=$(basename "$service_dir")
                current_services="${current_services}${service_name} "
                echo "ðŸ“¦ Found service: $service_name"
              fi
            done
          fi

          # Remove trailing space and save to environment
          current_services=$(echo "$current_services" | sed 's/[[:space:]]*$//')
          echo "CURRENT_SERVICES=$current_services" >> $GITHUB_ENV
          echo "current_services=$current_services" >> $GITHUB_OUTPUT

          echo "ðŸ“‹ Current services: $current_services"

      - name: Load previously deployed services
        id: previous
        run: |
          echo "ðŸ“– Loading previously deployed services..."

          # Try to get previously deployed services from a persistent location
          # Using a file in the runner's workspace that persists between runs
          previous_services=""
          if [ -f "$HOME/deployed_services.txt" ]; then
            previous_services=$(cat "$HOME/deployed_services.txt" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
            echo "ðŸ“œ Previously deployed: $previous_services"
          else
            echo "ðŸ“ No previous deployment record found"
          fi

          echo "PREVIOUS_SERVICES=$previous_services" >> $GITHUB_ENV
          echo "previous_services=$previous_services" >> $GITHUB_OUTPUT

      - name: Determine service actions
        id: actions
        run: |
          echo "ðŸŽ¯ Determining required actions..."

          current_services="${{ env.CURRENT_SERVICES }}"
          previous_services="${{ env.PREVIOUS_SERVICES }}"

          # Convert to arrays
          current_array=($current_services)
          previous_array=($previous_services)

          # Find new services (in current but not in previous)
          new_services=""
          for service in ${current_array[@]}; do
            if [[ ! " ${previous_array[@]} " =~ " $service " ]]; then
              new_services="${new_services}$service "
            fi
          done

          # Find removed services (in previous but not in current)
          removed_services=""
          for service in ${previous_array[@]}; do
            if [[ ! " ${current_array[@]} " =~ " $service " ]]; then
              removed_services="${removed_services}$service "
            fi
          done

          # All current services need to be checked for updates
          update_services="$current_services"

          # Clean up trailing spaces
          new_services=$(echo "$new_services" | sed 's/[[:space:]]*$//')
          removed_services=$(echo "$removed_services" | sed 's/[[:space:]]*$//')
          update_services=$(echo "$update_services" | sed 's/[[:space:]]*$//')

          echo "NEW_SERVICES=$new_services" >> $GITHUB_ENV
          echo "REMOVED_SERVICES=$removed_services" >> $GITHUB_ENV
          echo "UPDATE_SERVICES=$update_services" >> $GITHUB_ENV

          echo "âœ¨ New services: $new_services"
          echo "ðŸ—‘ï¸  Removed services: $removed_services"
          echo "ðŸ”„ Services to update: $update_services"

      - name: Validate service configurations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
          DOMAIN: ${{ secrets.DOMAIN }}
        run: |
          echo "âœ… Validating Docker Compose configurations..."

          failed_services=""
          for service in ${{ env.UPDATE_SERVICES }}; do
            echo "ðŸ” Validating $service..."
            
            service_dir="${SERVICES_DIR}/$service"
            compose_file=""
            
            if [ -f "$service_dir/docker-compose.yml" ]; then
              compose_file="$service_dir/docker-compose.yml"
            elif [ -f "$service_dir/docker-compose.yaml" ]; then
              compose_file="$service_dir/docker-compose.yaml"
            elif [ -f "$service_dir/compose.yaml" ]; then
              compose_file="$service_dir/compose.yaml"
            elif [ -f "$service_dir/compose.yml" ]; then
              compose_file="$service_dir/compose.yml"
            else
              echo "âŒ No compose file found for $service"
              failed_services="${failed_services}$service "
              continue
            fi
            
            # Validate configuration
            echo "ðŸ”§ Using compose file: $compose_file"
            if ! docker-compose -f "$compose_file" config > /dev/null 2>&1; then
              echo "âŒ Invalid configuration for $service"
              echo "ðŸ” Debug: Let's see the actual error:"
              docker-compose -f "$compose_file" config 2>&1 || true
              failed_services="${failed_services}$service "
            else
              echo "âœ… Configuration valid for $service"
            fi
          done

          if [ ! -z "$failed_services" ]; then
            echo "âŒ Failed services: $failed_services"
            exit 1
          fi

      - name: Remove deleted services
        if: env.REMOVED_SERVICES != ''
        run: |
          echo "ðŸ—‘ï¸ Removing deleted services..."

          for service in ${{ env.REMOVED_SERVICES }}; do
            echo "ðŸ›‘ Removing service: $service"
            
            # Find containers with the service name pattern
            containers=$(docker ps -a --filter "name=${service}" --format "{{.Names}}" || true)
            
            if [ ! -z "$containers" ]; then
              echo "ðŸ›‘ Stopping and removing containers for $service..."
              echo "$containers" | xargs -r docker stop || true
              echo "$containers" | xargs -r docker rm || true
            fi
            
            # Remove networks (be careful not to remove shared networks)
            networks=$(docker network ls --filter "name=${service}" --format "{{.Name}}" | grep -v bridge | grep -v host | grep -v none || true)
            if [ ! -z "$networks" ]; then
              echo "ðŸŒ Removing networks for $service..."
              echo "$networks" | xargs -r docker network rm || true
            fi
            
            # Remove images with the service name (only if not used by other containers)
            images=$(docker images --filter "reference=*${service}*" --format "{{.Repository}}:{{.Tag}}" || true)
            if [ ! -z "$images" ]; then
              echo "ðŸžï¸ Removing unused images for $service..."
              echo "$images" | xargs -r docker rmi --force || true
            fi
            
            echo "âœ… Service $service removed successfully"
          done

      - name: Discover and Deploy Services
        id: deploy
        run: |
          chmod +x ./manage-services.sh
          ./manage-services.sh
        env:
          DOCKER_HOST: unix:///var/run/docker.sock
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
          DOMAIN: ${{ secrets.DOMAIN }}

      - name: Health check services
        if: env.CURRENT_SERVICES != ''
        run: |
          echo "ðŸ¥ Performing health checks..."

          for service in ${{ env.CURRENT_SERVICES }}; do
            echo "ðŸ” Checking health of $service..."
            
            service_dir="${SERVICES_DIR}/$service"
            compose_file=""
            
            if [ -f "$service_dir/docker-compose.yml" ]; then
              compose_file="docker-compose.yml"
            elif [ -f "$service_dir/docker-compose.yaml" ]; then
              compose_file="docker-compose.yaml"
            elif [ -f "$service_dir/compose.yaml" ]; then
              compose_file="compose.yaml"
            elif [ -f "$service_dir/compose.yml" ]; then
              compose_file="compose.yml"
            fi
            
            cd "$service_dir"
            
            # Check container status
            status=$(docker-compose -f "$compose_file" ps --format "table {{.Name}}\t{{.Status}}" || true)
            echo "ðŸ“Š Status for $service:"
            echo "$status"
            
            # Count running containers
            running_count=$(docker-compose -f "$compose_file" ps | grep -c "Up\|running" || echo "0")
            total_count=$(docker-compose -f "$compose_file" config --services | wc -l)
            
            echo "ðŸ“ˆ $service: $running_count/$total_count containers running"
            
            cd "$GITHUB_WORKSPACE"
          done

      - name: Update deployment record
        if: always()
        run: |
          echo "ðŸ“ Updating deployment record..."

          # Save current services to persistent file
          echo "${{ env.CURRENT_SERVICES }}" | tr ' ' '\n' > "$HOME/deployed_services.txt"

          echo "ðŸ’¾ Deployment record updated"

      - name: Cleanup unused Docker resources
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up unused Docker resources..."

          # Remove unused images (but keep images less than 24 hours old)
          docker image prune -f --filter "until=24h" || true

          # Remove unused networks
          docker network prune -f || true

          # Remove unused build cache
          docker builder prune -f --keep-storage 1GB || true

          echo "âœ… Cleanup completed"

      - name: Generate deployment summary
        if: always()
        run: |
          echo "ðŸ“Š Deployment Summary"
          echo "===================="
          echo "ðŸ• Timestamp: $(date)"
          echo "ðŸ“¦ Total services: $(echo '${{ env.CURRENT_SERVICES }}' | wc -w)"
          echo "âœ… Successful: ${{ env.SUCCESSFUL_DEPLOYMENTS }}"
          echo "âŒ Failed: ${{ env.FAILED_DEPLOYMENTS }}"
          echo "ðŸ—‘ï¸ Removed: ${{ env.REMOVED_SERVICES }}"
          echo ""

          echo "ðŸ” Current Docker status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | head -20

          echo ""
          echo "ðŸ’½ Docker disk usage:"
          docker system df

          # Save summary to file for potential use in notifications
          cat > logs/deployment-summary.txt << EOF
          Deployment Summary - $(date)
          ============================
          Repository: ${{ github.repository }}
          Commit: ${{ github.sha }}
          Successful deployments: ${{ env.SUCCESSFUL_DEPLOYMENTS }}
          Failed deployments: ${{ env.FAILED_DEPLOYMENTS }}
          Removed services: ${{ env.REMOVED_SERVICES }}
          EOF

      - name: Notify on failure
        if: failure()
        run: |
          echo "ðŸš¨ Deployment failed! Check the logs above for details."
          echo "Failed services: ${{ env.FAILED_DEPLOYMENTS }}"

          # You can add notification logic here (Slack, email, etc.)
          # Example: Send to webhook
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"Docker deployment failed for ${{ github.repository }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
